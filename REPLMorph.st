SystemOrganization addCategory: #REPLMorph!Object subclass: #Continuation	instanceVariableNames: 'values'	classVariableNames: ''	poolDictionaries: ''	category: 'REPLMorph'!PluggableTextMorphWithModel subclass: #REPLMorph	instanceVariableNames: 'evaluator commandsHistory lastAnswer lastError debugContinuation lastValue queue outputQueueProcess semaphore'	classVariableNames: ''	poolDictionaries: ''	category: 'REPLMorph'!PluggableTextMorph subclass: #REPLPluggableTextMorph	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'REPLMorph'!TextMorphEditor subclass: #REPLTextMorphEditor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'REPLMorph'!TextMorphForEditView subclass: #REPLTextMorphForEditView	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'REPLMorph'!Continuation class	instanceVariableNames: ''!REPLMorph class	instanceVariableNames: ''!REPLPluggableTextMorph class	instanceVariableNames: ''!REPLTextMorphEditor class	instanceVariableNames: ''!REPLTextMorphForEditView class	instanceVariableNames: ''!!Continuation commentStamp: 'spfa 6/18/2006 22:13' prior: 0!Continuation class borrowed from Seaside(author: Avi Bryant) !]style[(62)f1!!REPLMorph commentStamp: '<historical>' prior: 0!a PluggableTextMorph providing a read-eval-print loop for interaction with an interpreter or compiler, called evaluatorevaluator must provide a #prompt, an #outputStream and an #evalString: method !!REPLMorph methodsFor: 'command processing' stamp: 'spfa 6/29/2008 14:47'!acceptDroppingMorph: aMorph event: evt inMorph: dstListMorph 		| commands |	(aMorph hasProperty: #replCommands) ifFalse: [^ self].	commands _ (aMorph valueOfProperty: #replCommands) 					difference: self commandsHistory.	((commands size > 1		and: [self confirm: 'Add these ', commands size asString, ' commands to history ?'])	or: [(commands size = 1		and: [self confirm: 'Add this command to history ?'])])		ifFalse: [^ self addMorph: aMorph].	commands do: [:command | self registerCommand: command].	^ true! !!REPLMorph methodsFor: 'contents' stamp: 'spfa 6/27/2008 14:14'!acceptTextInModel	| textToAccept command |	(self hasProperty: #inCommand)	ifFalse:	[		command _ self currentCommandFor: textMorph contents.		command ifEmpty: [command _ self pointedCommand].		(command isNil or: [command isEmpty]) ifTrue: [^ self].		self insertCommand: command.	].	textToAccept := textMorph asText.	^setTextSelector isNil or:		[setTextSelector numArgs = 2			ifTrue: [model perform: setTextSelector with: textToAccept with: self]			ifFalse: [model perform: setTextSelector with: textToAccept]]! !!REPLMorph class methodsFor: 'colors' stamp: 'spfa 6/8/2006 14:01'!answerAttribute	^ TextColor color: Color gray darker! !!REPLMorph methodsFor: 'display stream protocol' stamp: 'spfa 6/27/2008 12:22'!appendEntry	| stream text |	stream := evaluator outputStream.	stream isEmpty ifTrue: [^ self].	text := stream contents.	stream resetContents.		self queue nextPut: ((text asString copyReplaceAll: String lf with: String cr)		asText 			addAttribute: self class displayAttribute;			addAttribute: self class displayFontAttribute).! !!REPLMorph methodsFor: 'command processing' stamp: 'spfa 6/29/2008 13:50'!buildMenu: aMenu	self commandsHistory do: [:command |		| str |		str := command asString withBlanksTrimmed.		aMenu add: (str truncateWithElipsisTo: 70)				selector: #insertCommand: argument: str].	lastAnswer ifNotNil: [		| str |		str := lastAnswer asString withBlanksTrimmed.		aMenu addLine.		aMenu add: (str truncateWithElipsisTo: 70)				selector: #insertCommand: argument: str;				add: 'explore last value' target: lastValue selector: #explore].	evaluator addItemsToREPLMenu: aMenu.	commandsHistory isEmpty ifTrue:		[aMenu add: 'no history yet' action: #yourself]	ifFalse:		[			aMenu addLine;			add: 'display history' action: #displayHistory;			add: 'grab history' action: #grabHistory		].	debugContinuation ifNotNil: [		aMenu addLine.		aMenu add: (('DEBUG ', lastError) truncateWithElipsisTo: 70)			 target: debugContinuation selector: #value].	^ aMenu! !!REPLPluggableTextMorph methodsFor: 'as yet unclassified' stamp: 'spfa 6/18/2006 20:23'!buildMenu: aMenu	model buildMenu: aMenu.	^ aMenu! !!REPLMorph methodsFor: 'contents' stamp: 'spfa 9/28/2006 23:27'!characterLimit	"we should be able to set this interactively"	^ 30000! !!REPLMorph methodsFor: 'display stream protocol' stamp: 'spfa 5/27/2008 23:29'!clear	self updateText: '' "self prompt".	self refreshDisplay: self prompt.! !!REPLMorph class methodsFor: 'colors' stamp: 'spfa 6/8/2006 14:12'!commandAttribute	^ TextColor color: Color blue muchDarker! !!REPLMorph methodsFor: 'command processing' stamp: 'spfa 6/7/2006 23:44'!commandsHistory	^ commandsHistory ifNil: [commandsHistory _ OrderedCollection new]! !!Continuation class methodsFor: 'instance creation' stamp: 'ab 6/15/2003 19:13'!current	^ self fromContext: thisContext sender! !!REPLMorph methodsFor: 'command processing' stamp: 'spfa 6/27/2008 13:14'!currentCommandFor: text	| lastLinePos lastLine  |	lastLinePos _ text lastIndexOfSubCollection: (String cr, self prompt asString withoutTrailingBlanks)  ifAbsent: [0]."	lastLinePos _ text lastIndexOf: Character cr ifAbsent: [ 0 ]."	lastLinePos _ text asString skipAnySubStr: {self prompt asString withoutTrailingBlanks} startingAt: lastLinePos + 1.	lastLine _ text copyFrom: lastLinePos to: text size.	^ lastLine asString withBlanksTrimmed! !!Continuation class methodsFor: 'instance creation' stamp: 'ab 6/15/2003 19:13'!currentDo: aBlock	^ aBlock value: (self fromContext: thisContext sender)! !!REPLTextMorphEditor methodsFor: 'as yet unclassified' stamp: 'spfa 5/29/2008 14:30'!cursorPageDown: characterStream 	self isOnPromptLine		ifTrue: [model insertNextCommand. ^ true].	^ super cursorPageDown: characterStream ! !!REPLTextMorphEditor methodsFor: 'as yet unclassified' stamp: 'spfa 5/29/2008 14:30'!cursorPageUp: characterStream 	self isOnPromptLine		ifTrue: [model insertPreviousCommand. ^ true].	^ super cursorPageUp: characterStream ! !!REPLMorph class methodsFor: 'colors' stamp: 'spfa 6/8/2006 14:01'!displayAttribute	^ TextColor color: Color red muchDarker muchDarker! !!REPLMorph class methodsFor: 'colors' stamp: 'spfa 10/2/2006 09:53'!displayFont	^ (TextStyle named: #Accumon) 		fontOfSize: TextStyle defaultFont pointSize! !!REPLMorph class methodsFor: 'colors' stamp: 'spfa 6/27/2008 12:22'!displayFontAttribute	^ TextFontReference toFont: self displayFont! !!REPLMorph methodsFor: 'command processing' stamp: 'spfa 5/29/2008 15:11'!displayHistory	(Workspace new contents: (String streamContents: [:str |		self commandsHistory do: [:command |			str nextPutAll: command; cr]])) 		openLabel: 'commands history'	! !!REPLMorph methodsFor: 'display stream protocol' stamp: 'spfa 6/25/2008 10:39'!doCommand: aString	| answer |	self setProperty: #inCommand toValue: true.	self registerCommand: aString.	debugContinuation := lastAnswer := lastError := lastValue :=  nil.	answer :=  [lastAnswer := (self formatAnswer: 						(lastValue := evaluator evalString: aString notifying: self)) 								asText addAttribute: self class answerAttribute]		on: Error		do: [:ex | 				debugContinuation := Continuation current.				debugContinuation isContinuation					ifTrue: [(lastError := ex description) asText 								addAttribute: self class errorAttribute]					ifFalse: [ex signal]].	self setProperty: #inCommand toValue: false.	self appendEntry; outputQueue.	self updateText: myContents, answer, String cr.	self refreshDisplay: self prompt.! !!REPLTextMorphEditor methodsFor: 'as yet unclassified' stamp: 'spfa 5/29/2008 14:17'!encompassLine: anInterval	"Return an interval that encompasses the entire line, minus the promt if present at the beginning"	| string left right |	string _ paragraph text string.	left _ (string lastIndexOf: Character cr startingAt: anInterval first - 1 ifAbsent:[0]) + 1.	left == 		(string indexOfSubCollection: model prompt startingAt: left ifAbsent: [nil]) 	ifTrue: [left _ left + model prompt size].	right _ (string indexOf: Character cr startingAt: anInterval last + 1 ifAbsent: [string size + 1]) - 1.	^left to: right! !!REPLMorph methodsFor: 'display stream protocol' stamp: 'spfa 5/29/2008 13:11'!endEntry	self appendEntry.	(outputQueueProcess notNil		and: [outputQueueProcess isTerminated not]) ifTrue: [^ self].	outputQueueProcess _ [50 milliSeconds asDelay wait . self outputQueue] fork! !!REPLMorph class methodsFor: 'colors' stamp: 'spfa 6/18/2006 22:26'!errorAttribute	^ TextColor color: Color red! !!REPLMorph methodsFor: 'contents' stamp: 'spfa 6/16/2008 13:48'!evalText: aString	^ evaluator evalText: aString! !!REPLTextMorphEditor methodsFor: 'as yet unclassified' stamp: 'spfa 6/9/2008 15:16'!evaluateSelection	"Treat the current selection as an expression; evaluate it and return the result"	self lineSelectAndEmptyCheck: [^ ''].	^ model evalString: self selectionAsStream contents asString! !!REPLMorph methodsFor: 'initialization' stamp: 'spfa 6/29/2008 14:26'!evaluator: anObject	| fresh |	(self hasProperty: #inCommand) ifTrue: [^ self].	fresh _ ''.	evaluator ifNotNil: [		self appendEntry; outputQueue.		fresh _ self freshInput. 		[fresh beginsWith: String cr] whileTrue: [fresh _ fresh allButFirst].		(fresh beginsWith: self prompt) 			ifTrue:	[fresh _ fresh allButFirst: self prompt size]].	evaluator := anObject.	self appendEntry; outputQueue.	evaluator outputStream reset.	self refreshDisplay: self prompt, fresh! !!REPLMorph methodsFor: 'command processing' stamp: 'spfa 6/23/2008 00:13'!formatAnswer: anObject	^ anObject printString			! !!REPLMorph methodsFor: 'contents' stamp: 'spfa 5/29/2008 15:25'!freshInput	| len tlen |	len _ myContents ifNil: [0] ifNotNil: [myContents size].	tlen _ textMorph asText size.	tlen == len ifTrue: [^ ''].	^ textMorph asText copyFrom: len to: textMorph asText size! !!Continuation class methodsFor: 'instance creation' stamp: 'ab 6/15/2003 19:13'!fromContext: aStack	^self new initializeFromContext: aStack! !!REPLMorph methodsFor: 'contents' stamp: 'spfa 6/7/2006 22:09'!getMyText	^myContents! !!REPLMorph methodsFor: 'command processing' stamp: 'spfa 6/29/2008 14:45'!grabHistory	| n |	n _  self commandsHistory size.	n > 0 ifFalse: [^ self].	((StringMorph contents: n asString, ' command', (n>1 ifTrue: ['s'] ifFalse: ['']))		setProperty: #replCommands toValue: self commandsHistory)	openInHand! !!REPLMorph class methodsFor: 'as yet unclassified' stamp: 'spfa 6/8/2006 14:11'!historyLength	^ 30! !!REPLMorph methodsFor: 'initialization' stamp: 'spfa 6/25/2008 11:21'!initialize	super initialize.	self extent: 600@400.	self color: Color white.	self acceptOnCR: true."	self alwaysShowVScrollBar: true."	getMenuSelector := #buildMenu:.	self startStepping	! !!Continuation methodsFor: 'private' stamp: 'avi 4/24/2004 12:39'!initializeFromContext: aContext	| valueStream context |	valueStream _ WriteStream on: (Array new: 20).	context _ aContext.	[context notNil] whileTrue:		[valueStream nextPut: context.		1 to: context class instSize do: [:i | valueStream nextPut: (context instVarAt: i)].		1 to: context localSize do: [:i | valueStream nextPut: (context localAt: i)].		context _ context sender].	values _ valueStream contents! !!REPLMorph methodsFor: 'command processing' stamp: 'spfa 6/29/2008 14:23'!insertCommand: aString	textMorph newContents: (Text streamContents: [:str |		| txt |		str nextPutAll: (myContents ifNil: ['']).		(self hasProperty: #inCommand) ifFalse: [			myContents isEmptyOrNil ifFalse: [				myContents last == Character cr ifFalse: [str cr]].			str nextPutAll: self prompt].		txt _ (Text fromString: aString) 					addAttribute: self class commandAttribute.		(self hasProperty: #inCommand) 			ifTrue: [txt addAttribute: self class displayFontAttribute].		str nextPutAll: txt]).	textMorph editor selectAt: textMorph asText size + 1.	self hasUnacceptedEdits: true! !!REPLMorph methodsFor: 'command processing' stamp: 'spfa 5/29/2008 14:36'!insertNextCommand	| command |	self commandsHistory ifEmpty: [^ self].	self insertCommand: (command _ commandsHistory first).	commandsHistory removeFirst.	commandsHistory addLast: command! !!REPLMorph methodsFor: 'command processing' stamp: 'spfa 5/29/2008 14:37'!insertPreviousCommand	| command |	self commandsHistory ifEmpty: [^ self].	self insertCommand: (command _ commandsHistory last).	commandsHistory removeLast.	commandsHistory addFirst: command! !!REPLTextMorphForEditView methodsFor: 'as yet unclassified' stamp: 'spfa 6/16/2008 13:43'!installEditorToReplace: priorEditor	"Install an editor for my paragraph.  This constitutes 'hasFocus'.	If priorEditor is not nil, then initialize the new editor from its state.	We may want to rework this so it actually uses the prior editor."	| stateArray |	priorEditor ifNotNil: [stateArray := priorEditor stateArray].	editor := REPLTextMorphEditor new morph: self.	editor changeParagraph: self paragraph.	priorEditor ifNotNil: [editor stateArrayPut: stateArray].	self selectionChanged.	^ editor! !!Continuation methodsFor: 'testing' stamp: 'spfa 6/18/2006 22:14'!isContinuation	^ true! !!Object methodsFor: '*REPLMorph-continuations' stamp: 'spfa 6/18/2006 22:14'!isContinuation	^ false! !!REPLTextMorphEditor methodsFor: 'as yet unclassified' stamp: 'spfa 5/29/2008 14:25'!isOnPromptLine	^ self isPromptLine: self selectionInterval! !!REPLTextMorphEditor methodsFor: 'as yet unclassified' stamp: 'spfa 5/29/2008 14:24'!isPromptLine: anInterval	| string left |	string _ paragraph text string.	left _ (string lastIndexOf: Character cr startingAt: anInterval first - 1 ifAbsent:[0]) + 1.	^ left == 		(string indexOfSubCollection: model prompt startingAt: left ifAbsent: [nil]) ! !!REPLTextMorphForEditView methodsFor: 'as yet unclassified' stamp: 'spfa 10/20/2006 14:38'!keyStroke: evt	"	editView lisp standardInput stream nextPut: evt keyCharacter."	super keyStroke: evt! !!SequenceableCollection methodsFor: '*REPLMorph' stamp: 'spfa 10/3/2006 10:29'!lastIndexOfSubCollection: sub ifAbsent: exceptionBlock	"Answer the index of the receiver's last element, such that that element 	equals the first element of sub, and the next elements equal 	the rest of the elements of sub. Begin the search at element 	end of the receiver. If no such match is found, answer the result of 	evaluating argument, exceptionBlock."	| first index |	sub isEmpty ifTrue: [^ exceptionBlock value].	first _ sub first.	self size - sub size + 1 to: 1 by: -1 do:		[:startIndex |		(self at: startIndex) = first ifTrue:			[index _ 1.			[(self at: startIndex+index-1) = (sub at: index)]				whileTrue:				[index = sub size ifTrue: [^startIndex].				index _ index+1]]].	^ exceptionBlock value! !!ContextPart methodsFor: '*REPLMorph-continuations' stamp: 'avi 4/24/2004 12:27'!localAt: aNumber	^ self at: aNumber! !!ContextPart methodsFor: '*REPLMorph-continuations' stamp: 'avi 4/24/2004 12:27'!localAt: aNumber put: anObject	^ self at: aNumber put: anObject! !!ContextPart methodsFor: '*REPLMorph-continuations' stamp: 'avi 4/24/2004 12:27'!localSize	^ self size! !!Continuation methodsFor: 'invocation' stamp: 'ab 6/15/2003 19:18'!numArgs	^ 1! !!REPLMorph class methodsFor: 'instance creation' stamp: 'spfa 6/16/2008 13:46'!on: anObject	^ self new evaluator: anObject! !!REPLMorph methodsFor: 'display stream protocol' stamp: 'spfa 5/27/2008 23:04'!outputQueue	| fresh |	self queue isEmpty ifTrue: [^ self].	fresh _ self freshInput. 	self updateText: (Text streamContents: [:stream |							stream nextPutAll: (myContents ifNil: ['']).							self queue size timesRepeat: 								[stream nextPutAll: self queue next]]).	self refreshDisplay: fresh! !!REPLMorph methodsFor: 'command processing' stamp: 'spfa 6/27/2008 13:16'!pointedCommand	| beg end text line prompt |	text _ textMorph contents asString.	end _ (text indexOf: Character cr startingAt: selectionInterval last ifAbsent: [text size + 1]) - 1.		beg _ text lastIndexOf: Character cr startingAt: end ifAbsent: [0].	line _ text asString copyFrom: beg + 1 to: end.	prompt  _ self prompt asString withoutTrailingBlanks.	(line beginsWith: prompt) ifFalse: [^ nil].	^ (line copyFrom: (line skipAnySubStr: {prompt} startingAt: 1) to: line size)			withBlanksTrimmed! !!REPLTextMorphEditor methodsFor: 'as yet unclassified' stamp: 'spfa 6/9/2008 15:16'!printIt	"Treat the current text selection as an expression; evaluate it. Insert the 	description of the result of evaluation after the selection and then make 	this description the new text selection."	| result |	result _ self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [view flash]			ifFalse: [self afterSelectionInsertAndSelect: (result printString)]! !!REPLMorph methodsFor: 'initialization' stamp: 'spfa 6/16/2008 13:47'!prompt		^ evaluator prompt, ' '! !!REPLMorph methodsFor: 'initialization' stamp: 'spfa 9/28/2006 22:43'!queue	^ queue ifNil: [queue _ SharedQueue new]! !!REPLMorph methodsFor: 'contents' stamp: 'spfa 6/27/2008 14:32'!refreshDisplay: freshText	| fullText |	fullText _ myContents ifNil: [freshText] 		ifNotNil: [myContents, freshText].	textMorph newContents: fullText.	self selectFrom: fullText size + 1 to: fullText size + 1.	self scrollSelectionIntoView; setScrollDeltas; refreshWorld.	! !!REPLMorph methodsFor: 'command processing' stamp: 'spfa 5/29/2008 13:16'!registerCommand: aString	self commandsHistory remove: aString ifAbsent: [].	commandsHistory addFirst: aString.	commandsHistory size > self class historyLength		 ifTrue: [commandsHistory removeLast].! !!Continuation methodsFor: 'as yet unclassified' stamp: 'avi 4/24/2004 12:39'!restoreValues	| valueStream context |	valueStream _ values readStream.	[valueStream atEnd] whileFalse:		[context _ valueStream next.		1 to: context class instSize do: [:i | context instVarAt: i put: valueStream next].		1 to: context localSize do: [:i | context localAt: i put: valueStream next]]! !!REPLTextMorphEditor methodsFor: 'as yet unclassified' stamp: 'spfa 5/26/2006 11:25'!selectionAsStream	"Answer a ReadStream on the text in the paragraph that is currently 	selected."	^PositionableStream		on: paragraph string		from: self startIndex		to: self stopIndex - 1! !!REPLMorph methodsFor: 'display stream protocol' stamp: 'spfa 6/23/2008 21:41'!semaphore	^ semaphore ifNil: [semaphore _ Semaphore forMutualExclusion]! !!REPLMorph methodsFor: 'contents' stamp: 'spfa 6/27/2008 19:56'!setMyText: text	| command  |	(self hasProperty: #inCommand)	ifTrue:	[ | psize form |		psize _ myContents size.		(psize <= text size) ifTrue:		[			self updateText: 				((text, String cr) 					addAttribute: self class commandAttribute from: psize + 1 to: text size+1;					addAttribute: self class displayFontAttribute from: psize + 1 to: text size+1).			self refreshDisplay: ''.			form _ text copyFrom: psize + 1 to: text size.			self registerCommand: form asString.			evaluator inputStream nextPutAll: form asString.			evaluator inputStream skip: form size negated.		].		^ self 	].	(command _ self currentCommandFor: text) isEmpty 	ifFalse: [ 			self updateText: text, String cr.			self refreshDisplay: ''.	"		[self doCommand: command] fork."			self doCommand: command	]	ifTrue: [self updateText: text ].! !!REPLMorph methodsFor: 'initialization' stamp: 'spfa 6/16/2008 13:43'!setText: aText	scrollBar setValue: 0.0.	textMorph		ifNil: [textMorph := REPLTextMorphForEditView new						contents: aText wrappedTo: self innerBounds width-6.				textMorph setEditView: self.				scroller addMorph: textMorph]		ifNotNil: [textMorph newContents: aText].	self hasUnacceptedEdits: false.	self setScrollDeltas.! !!REPLPluggableTextMorph methodsFor: 'as yet unclassified' stamp: 'spfa 6/16/2008 13:43'!setText: aText	scrollBar setValue: 0.0.	textMorph		ifNil: [textMorph := REPLTextMorphForEditView new						contents: aText wrappedTo: self innerBounds width-6.				textMorph setEditView: self.				scroller addMorph: textMorph]		ifNotNil: [textMorph newContents: aText].	self hasUnacceptedEdits: false.	self setScrollDeltas.! !!REPLPluggableTextMorph methodsFor: 'as yet unclassified' stamp: 'spfa 6/1/2006 09:55'!spawn! !!REPLTextMorphEditor methodsFor: 'as yet unclassified' stamp: 'spfa 6/1/2006 09:54'!spawn	! !!REPLMorph methodsFor: 'stepping' stamp: 'spfa 6/17/2008 11:35'!step	self endEntry! !!REPLMorph methodsFor: 'stepping' stamp: 'spfa 6/17/2008 11:35'!stepTime	^ 200! !!Continuation methodsFor: 'private' stamp: 'ab 6/15/2003 19:13'!terminate: aContext	| context |	context _ aContext.	[context notNil] whileTrue: [context _ context swapSender: nil]! !!REPLMorph methodsFor: 'display stream protocol' stamp: 'spfa 5/29/2008 12:36'!update: aSymbol 	aSymbol ifNil: [^self].	aSymbol == #endEntry 		ifTrue: 			[self endEntry].	aSymbol == #appendEntry 		ifTrue: 			[self appendEntry].	aSymbol == #clearText 		ifTrue: 			[self clear].	aSymbol == #force 		ifTrue: 			[self outputQueue].! !!REPLMorph methodsFor: 'contents' stamp: 'spfa 6/25/2008 11:26'!updateText: text	| ttext |	ttext _ text size > self characterLimit 		ifTrue: [text copyFrom: text size - self characterLimit to: text size]		ifFalse: [text].	super setMyText: ttext.! !!Continuation methodsFor: 'invocation' stamp: 'ab 6/15/2003 19:13'!value	self value: nil! !!Continuation methodsFor: 'invocation' stamp: 'ab 6/15/2003 19:12'!value: v	self terminate: thisContext.	self restoreValues.	thisContext swapSender: values first.	^v! !!Continuation methodsFor: 'invocation' stamp: 'ab 6/15/2003 19:22'!valueWithArguments: v	v size == 1 ifFalse: [^self error: 'continuations can only be resumed with one argument'].	self value: v first! !!REPLMorph methodsFor: 'command processing' stamp: 'spfa 6/29/2008 14:47'!wantsDroppedMorph: aMorph event: evt	^ aMorph hasProperty: #replCommands		! !!REPLMorph methodsFor: 'initialization' stamp: 'spfa 6/18/2006 23:05'!wantsFrameAdornments	^ false! !!REPLMorph methodsFor: 'stepping' stamp: 'spfa 6/17/2008 11:35'!wantsSteps	^ true! !!REPLMorph methodsFor: 'command processing' stamp: 'spfa 6/18/2006 22:06'!yellowButtonActivity	(self getMenu: false) invokeModal! !!REPLPluggableTextMorph methodsFor: 'as yet unclassified' stamp: 'spfa 6/18/2006 21:32'!yellowButtonActivity	(self getMenu: false) invokeModal! !!REPLMorph methodsFor: 'command processing' stamp: 'spfa 6/18/2006 22:06'!yellowButtonActivity: shiftKeyState	(self getMenu: shiftKeyState) invokeModal! !!REPLPluggableTextMorph methodsFor: 'as yet unclassified' stamp: 'spfa 6/18/2006 21:31'!yellowButtonActivity: shiftKeyState	(self getMenu: shiftKeyState) invokeModal! !