AlignmentMorph subclass: #CalculatorMorph	instanceVariableNames: 'display firstDigit operator previousOperator currentValue previousValue memory locked showTape memoryMorphs operatorMorphs digitMorphs rows angleType textMorph'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Calculator'!!CalculatorMorph commentStamp: 'rjh 7/6/2008 03:37' prior: 0!CalculatorMorph - ScriptableThis calculator works as a normal calculator, but it can also be driven using scripts. Go to the viewer (the eye) halo and in the viewer bring up the 'calculator' category.The calculations can be recorded in a text window. Click the newTape command in the viewer.The calculator uses degrees for sin, cos, etc., but this can be changed to radians.There is a single memory built into the calculator.Workings of the CalculatorExample: 15 + 47 =The + calculation is done when the = is pressed; everything happens 'one step behind', hence the use of previousValue & currentValue to hold the two values, and operator & previousOperator to store the command presses.The currentValue is what is shown in the display.  After the + is clicked the 15 still shows, so the 15 is moved to previousValue when the user clicks the first digit of the next number.!!CalculatorMorph methodsFor: 'memOps' stamp: 'rjh 7/5/2008 23:20'!add	self operation: #+! !!CalculatorMorph methodsFor: 'memOps' stamp: 'rjh 7/5/2008 23:24'!divide	self operation: #/! !!CalculatorMorph methodsFor: 'memOps' stamp: 'rjh 7/5/2008 23:24'!equals	self operation: #=! !!CalculatorMorph methodsFor: 'memOps' stamp: 'rjh 10/25/2007 21:01'!memoryAdd	locked ifTrue: [^self].	self operation: #=.	self tape: '(M+)'; tapeCr.	memory := (memory asNumber + currentValue asNumber) asString.	self memoryHighlight! !!CalculatorMorph methodsFor: 'memOps' stamp: 'rjh 10/23/2007 21:55'!memoryClear	locked ifTrue: [^self].	self tape: '(Mc)'; tapeCr.	memory := '0'.	self showDisplay.	self memoryHighlight! !!CalculatorMorph methodsFor: 'memOps' stamp: 'rjh 10/25/2007 00:43'!memoryRecall	locked ifTrue: [^self].	previousValue := currentValue.	currentValue := memory.	self tape: '(Mr=', currentValue, ')'; tapeCr.	firstDigit := false.	self showDisplay! !!CalculatorMorph methodsFor: 'memOps' stamp: 'rjh 10/25/2007 20:56'!memoryTake	locked ifTrue: [^self].	self operation: #=.	self tape: '(M-', currentValue ,')'; tapeCr.	memory := (memory asNumber - currentValue asNumber) asString.	self memoryHighlight! !!CalculatorMorph methodsFor: 'memOps' stamp: 'rjh 7/5/2008 23:24'!subtract	self operation: #-! !!CalculatorMorph methodsFor: 'memOps' stamp: 'rjh 7/5/2008 23:24'!times	self operation: #*! !!CalculatorMorph methodsFor: 'clearOps' stamp: 'RJH 7/6/2008 02:33'!clearAll	self tapeCr; tape: 'clearAll'; tapeCr.	locked := false.	firstDigit := true.	previousValue := '0'.	currentValue := '0'.	self showDisplay.	operator := #=! !!CalculatorMorph methodsFor: 'clearOps' stamp: 'rjh 10/23/2007 04:26'!clearEntry	locked ifTrue: [^self].	currentValue := '0'.	self showDisplay.! !!CalculatorMorph methodsFor: 'extraOps' stamp: 'rjh 7/6/2008 00:53'!function	| integerFns neutralFns realFns trigFns arcTrigFns fns index item |		operator = '=' ifFalse: [self operation: #=].	locked ifTrue: [^self].		integerFns := #(factorial truncated rounded).  "these return an integer"	neutralFns := #(abs squared).	"these return an integer or a float"	realFns := #(degreesToRadians radiansToDegrees exp ln log reciprocal).	"these return a float"	arcTrigFns := #(arcSin arcCos arcTan).	"these need to convert the returned from radians to degrees and then return a float"	trigFns := #(sin cos tan).	"these need to convert degrees to radians and then return a float"	fns := realFns, arcTrigFns, trigFns, neutralFns, integerFns.		index := MorphicUIManager new chooseFrom: fns.	index = 0 ifTrue: [^self].	item := fns at: index.		self tape: currentValue; tape: ' '; tape: item.	(self hasErrors: item) "anticipated problems"		ifFalse: [			(integerFns includes: item) ifTrue: [currentValue := (currentValue asNumber perform: item) asString].			(neutralFns includes: item) ifTrue: [currentValue := (currentValue asNumber perform: item) asString].			(realFns includes: item) ifTrue: [currentValue := (currentValue asNumber perform: item) asFloat asString].			(trigFns includes: item) ifTrue: [currentValue := (currentValue asNumber degreesToRadians perform: item) asFloat asString].			(arcTrigFns includes: item) ifTrue: [currentValue := (currentValue asNumber perform: item) radiansToDegrees asFloat asString].			(self hadErrors) "unanticipated problems"				ifTrue: [^self error: 'Error']].			self showDisplay.	self tape: ' = '; tape: currentValue; tapeCr.	firstDigit := true! !!CalculatorMorph methodsFor: 'extraOps' stamp: 'rjh 7/5/2008 22:40'!percent	" E.g., 0.45 becomes 45% "		locked ifTrue: [^self].	self operation: #=.	currentValue := (currentValue asNumber * 100) asString.	self showDisplay.	self tape: currentValue; tape: '%';tapeCr.! !!CalculatorMorph methodsFor: 'extraOps' stamp: 'rjh 7/4/2008 20:09'!pi	locked ifTrue: [^self]. 	previousValue := currentValue.	currentValue := (4.0 * (1.0 arcTan)) asString.	firstDigit := true..	self showDisplay.! !!CalculatorMorph methodsFor: 'extraOps' stamp: 'rjh 10/25/2007 21:02'!sign	locked ifTrue: [^self].	operator = '=' ifFalse: [self operation: #=].	currentValue := currentValue asNumber negated asString.	self showDisplay.	firstDigit := true.	self tape: ' sign='; tape: currentValue; tapeCr.! !!CalculatorMorph methodsFor: 'extraOps' stamp: 'rjh 10/25/2007 20:56'!sqrt	locked ifTrue: [^self].	operator = '=' ifFalse: [self operation: #=].	self tape: currentValue.	currentValue := currentValue asNumber sqrt asString.	self showDisplay.	firstDigit := true.	self tape: ' sqrt = '; tape: currentValue; tapeCr.! !!CalculatorMorph methodsFor: 'operations' stamp: 'rjh 10/25/2007 21:32'!calculate	| result |	locked ifTrue: [^self].	operator == #= ifTrue: [^currentValue].	operator == #+ ifTrue: [result := (previousValue asNumber + currentValue asNumber) asString].	operator == #- ifTrue: [result := (previousValue asNumber - currentValue asNumber) asString].	operator == #* ifTrue: [result := (previousValue asNumber * currentValue asNumber) asString].	operator == #^ ifTrue: [result := (previousValue asNumber raisedTo: currentValue asNumber) asString].	operator == #/ ifTrue: [		(currentValue asNumber == 0 or: [currentValue asNumber = 0]) ifTrue: [^'Divide by Zero'].		result := (previousValue asNumber asFloat / currentValue asNumber) asFloat asString].	^result	! !!CalculatorMorph methodsFor: 'operations' stamp: 'rjh 10/25/2007 21:26'!operation: newOperator	"there's a new operator - so deal with the old one first"		locked ifTrue: [^self].		firstDigit ifTrue: [previousValue := currentValue].  "eg 2*= (gives 4)"	operator = '=' 		ifTrue: [			self tape: currentValue; tape: newOperator.			newOperator = '=' ifTrue: [self tapeCr]]		ifFalse: [    "e.g, if 1 + 2 = then calculate the addition"			self tape: currentValue.			currentValue := self calculate.			self tape: ' = '; tape: currentValue; tapeCr.			self hadErrors ifTrue: [^self error: currentValue].			newOperator = '=' 				ifFalse: [self tape: currentValue, newOperator]].	self showDisplay.	firstDigit := true.		operator := newOperator  "now remember the new one"! !!CalculatorMorph methodsFor: 'errors' stamp: 'rjh 10/23/2007 02:37'!error: message	locked := true.	currentValue := message.	self showDisplay! !!CalculatorMorph methodsFor: 'errors' stamp: 'rjh 10/25/2007 00:29'!hadErrors	"error strings don't include numbers"	currentValue do: [ :char | (char between: $0 and: $9) ifTrue: [^false]].	^true! !!CalculatorMorph methodsFor: 'errors' stamp: 'rjh 10/25/2007 00:09'!hasErrors: item	item == #reciprocal 		ifTrue: [			currentValue = '0' 				ifTrue: [					self error: 'division by zero'.					^true] 				ifFalse: [					currentValue := (1.0/currentValue asNumber) asString.					^true]].	item == #factorial		ifTrue: [			currentValue asNumber isInteger				ifTrue: [^false]				ifFalse: [					self error: 'integer needed'.					^true]].	(item == #arcSin or: [item == #arcCos])		ifTrue: [			(currentValue asNumber between: -1.0 and: 1.0)				ifTrue: [^false]				ifFalse: [					self error: 'range error'.					^true]].	^false					! !!CalculatorMorph methodsFor: 'errors' stamp: 'RJH 7/6/2008 02:40'!locked	^locked! !!CalculatorMorph methodsFor: 'digit' stamp: 'rjh 10/23/2007 02:42'!decimal	locked ifTrue: [^self].	firstDigit ifTrue: [		firstDigit := false.		previousValue := currentValue.		currentValue := '0'].	currentValue := currentValue, '.'.	display contents: currentValue! !!CalculatorMorph methodsFor: 'digit' stamp: 'RJH 7/6/2008 02:34'!digit	locked ifTrue: [^'0'].	^display text last asString asNumber! !!CalculatorMorph methodsFor: 'digit' stamp: 'rjh 7/5/2008 18:23'!digit: digit	locked ifTrue: [^self].	firstDigit ifTrue: [		firstDigit := false.		previousValue := currentValue.		currentValue := ''].	currentValue = '0'		ifTrue: [currentValue := digit]		ifFalse: [currentValue := currentValue, digit asString].	self showDisplay.! !!CalculatorMorph methodsFor: 'display' stamp: 'rjh 10/25/2007 22:55'!memoryHighlight 	memoryMorphs do: [ :morph | 		memory = '0' 			ifTrue: [morph color: self opColor]			ifFalse: [morph color: self memColor]]! !!CalculatorMorph methodsFor: 'display' stamp: 'rjh 7/6/2008 04:03'!newTape	showTape := true.	textMorph := nil.	self textMorph! !!CalculatorMorph methodsFor: 'display' stamp: 'rjh 7/5/2008 23:49'!setDisplay: number	locked ifTrue: [^self].	firstDigit ifTrue: [		firstDigit := false.		previousValue := currentValue.		currentValue := ''].	currentValue := number asString.	self showDisplay.! !!CalculatorMorph methodsFor: 'display' stamp: 'rjh 7/5/2008 18:24'!showDisplay	display contents: currentValue.	self width: (display width + 14 max: self usualWidth). ! !!CalculatorMorph methodsFor: 'display' stamp: 'rjh 7/6/2008 03:17'!switchTape	showTape := showTape not.! !!CalculatorMorph methodsFor: 'display' stamp: 'rjh 7/6/2008 03:45'!tape: string	showTape ifFalse: [^self].	self textMorph contents: textMorph contents, string.	Transcript show: string! !!CalculatorMorph methodsFor: 'display' stamp: 'rjh 7/6/2008 03:49'!tapeCr	showTape ifFalse: [^self].	self textMorph contents: self textMorph contents, ''.	Transcript cr! !!CalculatorMorph methodsFor: 'display' stamp: 'rjh 7/6/2008 04:04'!textMorph	(textMorph isNil or: [textMorph owner isNil]) ifTrue: [		textMorph :=			TextMorph new				position: (75 + 100 atRandom) @ (300 + 100 atRandom);				borderWidth: 2;				backgroundColor: (					Color						r: 1.0 - ((100 atRandom) / 200.0)						g: 1.0 - ((100 atRandom) / 200.0)						b: 1.0 - ((100 atRandom) / 200.0));				contents: 'Calculator Tape';				openInWorld.		self tapeCr].	^textMorph! !!CalculatorMorph methodsFor: 'appearance' stamp: 'rjh 10/25/2007 02:08'!buttonWidth	^20! !!CalculatorMorph methodsFor: 'appearance' stamp: 'rjh 10/26/2007 01:12'!digitColor	self color luminance < 0.4 ifTrue: [^self color lighter lighter lighter lighter lighter lighter lighter].	^self color darker ! !!CalculatorMorph methodsFor: 'appearance' stamp: 'rjh 10/26/2007 01:16'!fillStyle: colour	super fillStyle: colour.	rows do: [ :morph | morph color: self color].	memoryMorphs do: [ :morph | morph color: self memColor].	digitMorphs do: [ :morph | morph color: self digitColor].	operatorMorphs do: [ :morph | morph color: self opColor].	self color luminance < 0.45 		ifTrue: [^self borderColor: Color lightGray]		ifFalse: [^self borderColor: Color black]! !!CalculatorMorph methodsFor: 'appearance' stamp: 'rjh 10/25/2007 02:07'!font	^(TextConstants at: #Accujen) fontArray first! !!CalculatorMorph methodsFor: 'appearance' stamp: 'rjh 10/26/2007 01:12'!memColor	self color luminance < 0.4 ifTrue: [^self color lighter lighter lighter lighter lighter lighter lighter].	^self color darker ! !!CalculatorMorph methodsFor: 'appearance' stamp: 'rjh 10/26/2007 01:12'!opColor	self color luminance < 0.4 ifTrue: [^self color lighter lighter lighter lighter lighter].	^self color lighter ! !!CalculatorMorph methodsFor: 'appearance' stamp: 'rjh 10/25/2007 02:02'!usualWidth	^self buttonWidth * 4 + 12! !!CalculatorMorph methodsFor: 'initialize' stamp: 'rjh 7/5/2008 22:38'!addCustomMenuItems: aCustomMenu hand: aHandMorphsuper addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'switch tape ', (showTape ifTrue: ['off'] ifFalse: ['on']) action: #switchTape! !!CalculatorMorph methodsFor: 'initialize' stamp: 'rjh 10/25/2007 22:37'!buttonLabel: label action: symbol arg: arg group: group 	| button |	button := SimpleButtonMorph new target: self;				actionSelector: symbol;				arguments: (arg ifNil: [#()] ifNotNil: [Array with: arg]);				label: label font: self font;				width: self buttonWidth;				useRoundedCorners;				recolor: Color green;				yourself.	group == #op		ifTrue: [button color: self opColor.			operatorMorphs add: button].	group == #memory		ifTrue: [button color: self memColor.			memoryMorphs add: button].	group == #digit		ifTrue: [button color: self digitColor.			digitMorphs add: button].	^ button! !!CalculatorMorph methodsFor: 'initialize' stamp: 'rjh 7/6/2008 01:05'!initialize	super initialize.	operator := #=.	currentValue := '0'.	previousValue := '0'.	memory := '0'.	display := '0'.	firstDigit := true.	locked := false.	showTape := false.	operatorMorphs := OrderedCollection new.	digitMorphs := OrderedCollection new.	memoryMorphs := OrderedCollection new.	angleType := 'degrees'.	self setupButtons.	"CaclulatorMorph - originated Oct 2007 by RHawley under MIT License (free use + no liability)"! !!CalculatorMorph methodsFor: 'initialize' stamp: 'rjh 10/25/2007 23:08'!setupButtons	| row |		self borderWidth: 2;		 width: self usualWidth;		 height: 184;		 useRoundedCorners;		 listDirection: #bottomToTop.	rows := OrderedCollection new.	row := AlignmentMorph new 			wrapCentering: #topLeft;			listDirection: #rightToLeft;			color: Color white;			borderWidth: 1;			useRoundedCorners;			addMorph: (				display := 					TextMorph new 						backgroundColor: Color white;						contents: '0';						borderWidth: 0;						rightFlush).	self addMorph: row.	row := AlignmentMorph new listDirection: #leftToRight;			addMorph: (self buttonLabel: 'fn' action: #function arg: nil group: #op);			addMorph: (self buttonLabel: 'Pi' action: #pi arg: nil group: #op);			addMorph: (self buttonLabel: '%' action: #percent arg: nil group: #op);			addMorph: (self buttonLabel: '±' action: #sign arg: nil group: #op).	self addMorph: row.	rows add: row.	row := AlignmentMorph new listDirection: #leftToRight;			addMorph: (self buttonLabel: 'Mc' action: #memoryClear arg: nil group: #memory);			addMorph: (self buttonLabel: 'Mr' action: #memoryRecall arg: nil group: #memory);			addMorph: (self buttonLabel: 'M-' action: #memoryTake arg: nil group: #memory);			addMorph: (self buttonLabel: 'M+' action: #memoryAdd arg: nil group: #memory).	self addMorph: row.	rows add: row.	row := AlignmentMorph new listDirection: #leftToRight;			addMorph: (self buttonLabel: '÷' action: #operation: arg: #/ group: #op);			addMorph: (self buttonLabel: '9' action: #digit: arg: '9' group: #digit);			addMorph: (self buttonLabel: '8' action: #digit: arg: '8' group: #digit);			addMorph: (self buttonLabel: '7' action: #digit: arg: '7' group: #digit).	self addMorph: row.	rows add: row.	row := AlignmentMorph new listDirection: #leftToRight;			addMorph: (self buttonLabel: 'x' action: #operation: arg: #* group: #op);			addMorph: (self buttonLabel: '6' action: #digit: arg: '6' group: #digit);			addMorph: (self buttonLabel: '5' action: #digit: arg: '5' group: #digit);			addMorph: (self buttonLabel: '4' action: #digit: arg: '4' group: #digit).	self addMorph: row.	rows add: row.	row := AlignmentMorph new listDirection: #leftToRight;			addMorph: (self buttonLabel: '-' action: #operation: arg: #- group: #op);			addMorph: (self buttonLabel: '3' action: #digit: arg: '3' group: #digit);			addMorph: (self buttonLabel: '2' action: #digit: arg: '2' group: #digit);			addMorph: (self buttonLabel: '1' action: #digit: arg: '1' group: #digit).	self addMorph: row.	rows add: row.	row := AlignmentMorph new listDirection: #leftToRight;			addMorph: (self buttonLabel: '+' action: #operation: arg: #+ group: #op);			addMorph: (self buttonLabel: '=' action: #operation: arg: #= group: #op);			addMorph: (self buttonLabel: '0' action: #digit: arg: '0' group: #digit);			addMorph: (self buttonLabel: '.' action: #decimal arg: nil group: #op).	self addMorph: row.	rows add: row.	row := AlignmentMorph new listDirection: #leftToRight;			addMorph: (self buttonLabel: 'C' action: #clearAll arg: nil group: #op);			addMorph: (self buttonLabel: 'c' action: #clearEntry arg: nil group: #op);			addMorph: (self buttonLabel: '^' action: #operation: arg: #^ group: #op);			addMorph: (self buttonLabel: '¦' action: #sqrt arg: nil group: #op).	self addMorph: row.	rows add: row.! !!CalculatorMorph methodsFor: 'scripting' stamp: 'rjh 7/5/2008 21:45'!newPlayerInstance	^ CalculatorPlayer newUserInstance! !!CalculatorMorph methodsFor: 'accessing' stamp: 'rjh 7/6/2008 01:04'!angleType	^ angleType! !!CalculatorMorph methodsFor: 'accessing' stamp: 'rjh 7/6/2008 01:04'!angleType: anObject	angleType := anObject! !!CalculatorMorph methodsFor: 'accessing' stamp: 'rjh 7/5/2008 22:27'!memory	^ memory asString asNumber! !!CalculatorMorph methodsFor: 'accessing' stamp: 'rjh 7/5/2008 22:27'!memory: anObject	memory := anObject asString! !!CalculatorMorph methodsFor: 'accessing' stamp: 'rjh 7/5/2008 23:08'!operator	^ operator! !!CalculatorMorph methodsFor: 'accessing' stamp: 'rjh 7/5/2008 23:08'!operator: anObject	operator := anObject! !!CalculatorMorph methodsFor: 'accessing' stamp: 'rjh 7/5/2008 22:37'!showTape	^ showTape! !!CalculatorMorph methodsFor: 'accessing' stamp: 'rjh 7/5/2008 22:37'!showTape: anObject	showTape := anObject! !!CalculatorMorph methodsFor: 'functions' stamp: 'rjh 7/6/2008 00:00'!abs	self doFunction: #abs! !!CalculatorMorph methodsFor: 'functions' stamp: 'rjh 7/5/2008 23:56'!arcCos	self doFunction: #arcCos! !!CalculatorMorph methodsFor: 'functions' stamp: 'rjh 7/5/2008 23:58'!arcSin	self doFunction: #arcSin! !!CalculatorMorph methodsFor: 'functions' stamp: 'rjh 7/5/2008 23:59'!arcTan	self doFunction: #arcTan! !!CalculatorMorph methodsFor: 'functions' stamp: 'rjh 7/5/2008 23:56'!cos	self doFunction: #cos! !!CalculatorMorph methodsFor: 'functions' stamp: 'rjh 7/6/2008 00:26'!degreesToRadians	self doFunction: #degreesToRadians! !!CalculatorMorph methodsFor: 'functions' stamp: 'rjh 7/6/2008 13:04'!doFunction: fn	| integerFns neutralFns realFns item |		operator = '=' ifFalse: [self operation: #=].	locked ifTrue: [^self].		integerFns := #(factorial truncated rounded).  "these return an integer"	neutralFns := #(abs squared).	"these return an integer or a float"	realFns := #(sin cos tan arcSin arcCos arcTan degreesToRadians radiansToDegrees exp ln log reciprocal random).	"these return a float"		item := fn.		self tape: currentValue; tape: ' '; tape: item.		(self hasErrors: item) "anticipated problems"		ifFalse: [			(integerFns includes: item) ifTrue: [currentValue := (currentValue asNumber perform: item) asString].			(neutralFns includes: item) ifTrue: [currentValue := (currentValue asNumber perform: item) asString].			(realFns includes: item) ifTrue: [currentValue := (currentValue asNumber perform: item) asFloat asString].			(self hadErrors) "unanticipated problems"				ifTrue: [^self error: 'Error']].			self showDisplay.	self tape: ' = '; tape: currentValue; tapeCr.	firstDigit := true! !!CalculatorMorph methodsFor: 'functions' stamp: 'rjh 7/6/2008 00:00'!exp	self doFunction: #exp! !!CalculatorMorph methodsFor: 'functions' stamp: 'rjh 7/5/2008 23:54'!factorial	self doFunction: #factorial! !!CalculatorMorph methodsFor: 'functions' stamp: 'RJH 7/6/2008 02:36'!getDisplay	locked ifTrue: [^display contents].	^display contents asNumber! !!CalculatorMorph methodsFor: 'functions' stamp: 'rjh 7/5/2008 23:59'!ln	self doFunction: #ln! !!CalculatorMorph methodsFor: 'functions' stamp: 'rjh 7/5/2008 23:59'!log	self doFunction: #log! !!CalculatorMorph methodsFor: 'functions' stamp: 'rjh 7/6/2008 00:26'!radiansToDegrees	self doFunction: #radiansToDegrees! !!CalculatorMorph methodsFor: 'functions' stamp: 'rjh 7/6/2008 13:03'!random	self doFunction: #atRandom! !!CalculatorMorph methodsFor: 'functions' stamp: 'rjh 7/5/2008 23:55'!reciprocal	self doFunction: #reciprocal! !!CalculatorMorph methodsFor: 'functions' stamp: 'rjh 7/5/2008 23:54'!rounded	self doFunction: #rounded! !!CalculatorMorph methodsFor: 'functions' stamp: 'rjh 7/5/2008 23:56'!sin	self doFunction: #sin! !!CalculatorMorph methodsFor: 'functions' stamp: 'rjh 7/5/2008 23:54'!squared	self doFunction: #squared! !!CalculatorMorph methodsFor: 'functions' stamp: 'rjh 7/5/2008 23:55'!tan	self doFunction: #tan! !!CalculatorMorph methodsFor: 'functions' stamp: 'rjh 7/5/2008 23:55'!truncated	self doFunction: #truncated! !!CalculatorMorph methodsFor: 'trig' stamp: 'rjh 7/6/2008 01:07'!useDegrees	angleType := 'Degrees'! !!CalculatorMorph methodsFor: 'trig' stamp: 'rjh 7/6/2008 01:08'!useRadians	angleType := 'Radians'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CalculatorMorph class	instanceVariableNames: ''!!CalculatorMorph class methodsFor: 'as yet unclassified' stamp: 'rjh 7/6/2008 03:30'!additionsToViewerCategoryCalculator	"Answer viewer additions for the 'calculator' category"	^#(		calculator 		(			(slot display 'The Number in the Calculator Display. (Set the decimal places using the menu)' Number readWrite Player getDisplay Player setDisplay:)			(slot digit 'The Number in the Calculator Display. (enter a digit)' Number readWrite Player getDigit Player setDigit:)			(slot operator 'Operator' String readWrite Player getOperator Player setOperator:)			(slot locked 'Locked after an error - click clearAll' Boolean readOnly Player getLocked Player setLocked:)			(command decimal 'Decimal Point' Number)			(command add 'Add' Number)			(command subract 'Subract' Number)			(command times 'Times' Number)			(command divide 'Divide' Number)			(command equals 'Equals' Number)			(command newTape 'Open a 'paper tape' - atext field to show the calculations' Number)			(slot showTape 'Switch Tape. (Shows in a Transcript window)' Boolean readWrite Player getShowTape Player setShowTape:)			(command clearAll 'Clear All' Number)			(command clearEntry 'Clear Entry' Number))					'calculator trig functions'		(			(command tan 'Tangent' Number)			(command sin 'Sine' Number)			(command cos 'Cosine' Number)			(command arcCos 'Arc Cosine' Number)			(command arcSin 'Arc Sine' Number)			(command arcTan 'Arc Tangent' Number)			(command degreesToRadians 'Degrees To Radians' Number)			(command radiansToDegrees 'Radians To Degrees' Number))					'calculator degrees or radians'		(			(command useRadians 'Use Radians for sin, cos, etc.' Number)			(command useDegrees 'Use Degrees for sin, cos, etc.' Number)			(slot using 'For cos, sin, etc.' String readOnly Player getAngleType Player setAngleType:))					'calculator math functions'		(			(command pi 'Pi' Number)			(command sign 'Sign change' Number)			(command sqrt 'Square Root' Number)			(command log 'Logarithm' Number)			(command ln 'Natural Logarithm' Number)			(command reciprocal 'Reciprocal' Number)			(command percent 'Percent' Number)			(command abs 'Absolute Value' Number)			(command rounded 'Rounded' Number)			(command truncated 'Truncated' Number)			(command squared 'Squared' Number)			(command exp 'Exponential' Number)			(command factorial 'Factorial' Number))					'calculator memory'		(			(command memoryAdd 'Add to memory' Number)			(command memoryTake 'Subtract from memory' Number)			(command memoryRecall 'Memory recall' Number)			(command memoryClear 'Clear Memory' Number)			(slot memory 'The Number in the Calculator memory. (Set the decimal places using the menu on the left)' Number readWrite Player getMemory Player setMemory:)		)	)! !!CalculatorMorph class methodsFor: 'as yet unclassified' stamp: 'rjh 10/24/2007 23:23'!descriptionForPartsBin	^ self partName:	'Calculator'		categories:		#('Useful')		documentation:	'A simple numerical calculator with additional mathematical functions and a single memory. Use menu option ''switch tape on'' to record the calculations.'! !!CalculatorMorph class methodsFor: 'as yet unclassified' stamp: 'rjh 10/25/2007 18:14'!new	^self basicNew initialize! !Player subclass: #CalculatorPlayer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Calculator'!!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:33'!abs 	self sendMessageToCostume: #abs! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:33'!add 	self sendMessageToCostume: #add! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:33'!arcCos 	self sendMessageToCostume: #arcCos! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:33'!arcSin 	self sendMessageToCostume: #arcSin! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:34'!arcTan 	self sendMessageToCostume: #arcTan! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:34'!clearAll 	self sendMessageToCostume: #clearAll! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:34'!clearEntry 	self sendMessageToCostume: #clearEntry! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:34'!cos 	self sendMessageToCostume: #cos! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:34'!decimal 	self sendMessageToCostume: #decimal! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:34'!degreesToRadians 	self sendMessageToCostume: #degreesToRadians! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:35'!divide 	self sendMessageToCostume: #divide! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:35'!equals 	self sendMessageToCostume: #equals! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:35'!exp 	self sendMessageToCostume: #exp! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:35'!factorial 	self sendMessageToCostume: #factorial! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:50'!getAngleType 	^ self getValueFromCostume: #angleType! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'rjh 7/5/2008 21:47'!getDigit	^ self getValueFromCostume: #digit! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'rjh 7/5/2008 21:54'!getDisplay	^ self getValueFromCostume: #getDisplay! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:50'!getLocked	^ self getValueFromCostume: #locked! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'rjh 7/5/2008 22:21'!getMemory	^ self getValueFromCostume: #memory! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'rjh 7/5/2008 23:07'!getOperation	^ self getValueFromCostume: #operation! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'rjh 7/5/2008 23:09'!getOperator	^ self getValueFromCostume: #operator! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:49'!getShowTape	^ self getValueFromCostume: #showTape! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:38'!ln 	self sendMessageToCostume: #ln! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:38'!log 	self sendMessageToCostume: #log! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:38'!memoryAdd 	self sendMessageToCostume: #memoryAdd! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:38'!memoryClear 	self sendMessageToCostume: #memoryClear! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:38'!memoryRecall 	self sendMessageToCostume: #memoryRecall! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:39'!memoryTake 	self sendMessageToCostume: #memoryTake! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:39'!newTape 	self sendMessageToCostume: #newTape! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:39'!percent 	self sendMessageToCostume: #percent! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:39'!pi 	self sendMessageToCostume: #pi! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:40'!radiansToDegrees 	self sendMessageToCostume: #radiansToDegrees! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:40'!reciprocal 	self sendMessageToCostume: #reciprocal! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:40'!rounded 	self sendMessageToCostume: #rounded! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:43'!setAngleType: n	self sendMessageToCostume: #angleType: with: n! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:44'!setDigit: d	self sendMessageToCostume: #digit: with: d! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:44'!setDisplay: d	self sendMessageToCostume: #setDisplay: with: d! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:45'!setMemory: m	self sendMessageToCostume: #memory: with: m! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:46'!setOperator: op	self sendMessageToCostume: #operator: with: op! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:47'!setShowTape: b	self sendMessageToCostume: #showTape: with: b! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:40'!sign 	self sendMessageToCostume: #sign! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:40'!sin 	self sendMessageToCostume: #sin! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:41'!sqrt 	self sendMessageToCostume: #sqrt! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:41'!squared 	self sendMessageToCostume: #squared! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:41'!subtract 	self sendMessageToCostume: #subtract! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:41'!switchTape 	self sendMessageToCostume: #switchTape! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:41'!tan 	self sendMessageToCostume: #tan! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:42'!times 	self sendMessageToCostume: #times! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:42'!truncated 	self sendMessageToCostume: #truncated! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:42'!useDegrees 	self sendMessageToCostume: #useDegrees! !!CalculatorPlayer methodsFor: 'as yet unclassified' stamp: 'RJH 7/10/2008 06:42'!useRadians 	self sendMessageToCostume: #useRadians! !