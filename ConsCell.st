SystemOrganization addCategory: #ConsCell!Object subclass: #ConsCell	instanceVariableNames: 'car cdr'	classVariableNames: ''	poolDictionaries: ''	category: 'ConsCell'!ConsCell class	instanceVariableNames: ''!!ConsCell commentStamp: '<historical>' prior: 0!a Lisp cons cell, or a Prolog list	it can be converted into an Array:	(ConsCell car: 1 cdr: (ConsCell car: 2 cdr: nil)) arrayForm    "printIt"	... or not:	(ConsCell car: 1 cdr: 2) arrayForm     "doIt"	it can be created from an Array:	#('hello' 'world') asCons        "printIt"!!ConsCell methodsFor: 'testing' stamp: 'spfa 3/24/2007 18:39'!= aConsCell	self isCircular ifTrue: 		[^ self withCut = aConsCell withCut].	self species = aConsCell species		ifTrue: [^ car = aConsCell car and: [cdr = aConsCell cdr]]		ifFalse: [^false]! !!ConsCell methodsFor: 'list operations' stamp: 'spfa 6/24/2008 18:14'!addLast: anObject	self lastCell cdr: (self tailClass car: anObject)! !!ConsCell methodsFor: 'list operations' stamp: 'spfa 3/30/2007 14:58'!append2: aConsCell	| a |	a _ aConsCell isConsCell ifTrue: [aConsCell listCopy] ifFalse: [aConsCell].	self append: a	! !!ConsCell methodsFor: 'list operations' stamp: 'spfa 5/20/2008 13:29'!append: aConsCell	self lastCell cdr: aConsCell	! !!Array methodsFor: '*ConsCell' stamp: 'spfa 5/31/2006 11:00'!arrayForm	^ self! !!ConsCell methodsFor: 'conversion' stamp: 'spfa 5/30/2006 17:05'!arrayForm	^ Array streamContents: [:stream | self inArray: stream]! !!UndefinedObject methodsFor: '*ConsCell' stamp: 'spfa 5/30/2006 17:09'!arrayForm	^ #()! !!Array methodsFor: '*ConsCell' stamp: 'spfa 4/13/2007 22:19'!asCons	| cons |	self size = 0 ifTrue: [^ nil].	self size = 1 ifTrue: [^ ConsCell car: (self at: 1) asCons].	self reverseDo: [:elt | 		cons _ ConsCell car: elt asCons cdr: cons].	^ cons! !!Object methodsFor: '*ConsCell' stamp: 'spfa 9/30/2006 15:06'!asCons	^ self! !!Array methodsFor: '*ConsCell' stamp: 'spfa 4/13/2007 22:19'!asConsList	| cons |	self size = 0 ifTrue: [^ nil].	self size = 1 ifTrue: [^ ConsCell car: (self at: 1)].	self size = 2 ifTrue: 		[^ ConsCell car: (self at: 1) cdr: (ConsCell car: (self at: 2))].	self size to: 1 by: -1 do: [:index | 			cons _ ConsCell car: (self at: index) cdr: cons].	^ cons! !!ConsCell methodsFor: 'accessing' stamp: 'spfa 6/8/2006 21:20'!caar	^ car car! !!ConsCell class methodsFor: 'instance creation' stamp: 'spfa 6/3/2006 01:28'!caar: anObject	^ self car: (self car: anObject) ! !!ConsCell methodsFor: 'accessing' stamp: 'spfa 6/9/2006 10:22'!cadr	^ cdr car! !!ConsCell methodsFor: 'accessing' stamp: 'spfa 6/3/2006 01:27'!car	^ car! !!UndefinedObject methodsFor: '*ConsCell' stamp: 'spfa 6/9/2006 10:21'!car	^ nil! !!ConsCell class methodsFor: 'instance creation' stamp: 'spfa 6/3/2006 01:32'!car: anObject	^ self new car: anObject ! !!ConsCell methodsFor: 'accessing' stamp: 'spfa 6/3/2006 01:27'!car: anObject	car _ anObject! !!ConsCell class methodsFor: 'instance creation' stamp: 'spfa 6/3/2006 01:31'!car: anObject cdr: bObject	^ (self new) car: anObject; cdr: bObject! !!ConsCell methodsFor: 'accessing' stamp: 'spfa 6/8/2006 21:50'!cdar	^ car cdr! !!ConsCell methodsFor: 'accessing' stamp: 'spfa 6/9/2006 10:22'!cddr	^ cdr cdr! !!ConsCell methodsFor: 'accessing' stamp: 'spfa 6/3/2006 01:27'!cdr	^ cdr! !!Object methodsFor: '*ConsCell' stamp: 'spfa 5/20/2008 13:27'!cdr	self error: 'not a list'! !!UndefinedObject methodsFor: '*ConsCell' stamp: 'spfa 6/9/2006 10:21'!cdr	^ nil! !!ConsCell methodsFor: 'accessing' stamp: 'spfa 6/3/2006 01:27'!cdr: anObject	cdr _ anObject! !!ConsCell methodsFor: 'list operations' stamp: 'spfa 6/21/2006 10:46'!cells	^ Array streamContents: [:str | 		self cellsDo: [:cell | str nextPut: cell]]! !!ConsCell methodsFor: 'list operations' stamp: 'spfa 5/20/2008 13:30'!cellsDo: aBlock	| cell |	cell _ self.	[cell isConsCell] whileTrue: [aBlock value: cell. cell _ cell cdr]! !!ConsCell methodsFor: 'list operations' stamp: 'spfa 6/23/2008 14:52'!collect: aBlock	^ self class car: (aBlock value: car)		cdr: (cdr isConsCell ifTrue: [cdr collect: aBlock] ifFalse: [cdr])! !!Array methodsFor: '*ConsCell' stamp: 'spfa 3/23/2007 17:12'!cycles	^ self storeCycles: IdentityDictionary new with: IdentitySet new! !!ConsCell methodsFor: 'testing' stamp: 'spfa 3/23/2007 16:46'!cycles	^ self storeCycles: IdentityDictionary new with: IdentitySet new! !!ConsCell methodsFor: 'list operations' stamp: 'spfa 5/20/2008 13:32'!detect: aBlock ifNone: bBlock	| cell |	cell _ self.	[cell isConsCell] whileTrue: [		(aBlock value: cell car) ifTrue: [^ cell car]. 		cell _ cell cdr].	^ bBlock value! !!ConsCell methodsFor: 'list operations' stamp: 'spfa 5/20/2008 13:22'!do: aBlock	| cell |	cell _ self.	[cell isConsCell] whileTrue: [aBlock value: cell car. cell _ cell cdr]! !!ConsCell methodsFor: 'list operations' stamp: 'spfa 5/20/2008 13:20'!doWithCdr: aBlock	| cell |	cell _ self.	[cell isConsCell] whileTrue: [aBlock value: cell car value: (cell _ cell cdr)]! !!ConsCell methodsFor: 'list operations' stamp: 'spfa 5/20/2008 13:33'!doWithCell: aBlock	| cell |	cell _ self.	[cell isConsCell] whileTrue: [aBlock value: cell car value: cell . cell _ cell cdr]! !!ConsCell methodsFor: 'accessing' stamp: 'spfa 6/3/2006 01:25'!first	^ car! !!ConsCell methodsFor: 'printing' stamp: 'spfa 10/10/2006 13:49'!fullPrintStringForLisp: aLisp	^ String streamContents: [:s | self printOn: s forLisp: aLisp]! !!ConsCell methodsFor: 'testing' stamp: 'spfa 3/24/2007 18:40'!hash	"Hash is reimplemented because = is implemented."	self isCircular ifTrue: [^ self withCut hash].	^ car hash bitXor: cdr hash.! !!ConsCell methodsFor: 'conversion' stamp: 'spfa 6/18/2006 14:45'!inArray: aStream	| k |	k _ car isConsCell ifTrue: [car arrayForm] ifFalse: [car].	k ifNil: [k _ #()].	cdr isNil ifTrue: [^ aStream nextPut: k].	cdr isConsCell ifTrue: [^ aStream nextPut: k; nextPutAll: cdr arrayForm].	self error: 'Not a list'! !!Object methodsFor: '*ConsCell' stamp: 'spfa 5/31/2006 21:21'!inCons	^ ConsCell car: self! !!ConsCell methodsFor: 'testing' stamp: 'spfa 3/24/2007 16:16'!isCircular	^ self isCircular: IdentitySet new! !!ConsCell methodsFor: 'testing' stamp: 'spfa 3/24/2007 16:16'!isCircular: anIdentitySet	cdr isConsCell ifFalse: [^ false].	(anIdentitySet includes: cdr) ifTrue: [^ true].	anIdentitySet add: self.	^ cdr isCircular: anIdentitySet ! !!ConsCell methodsFor: 'testing' stamp: 'spfa 5/24/2006 19:45'!isConsCell	^ true! !!Object methodsFor: '*ConsCell' stamp: 'spfa 5/24/2006 19:45'!isConsCell	^ false! !!ConsCell methodsFor: 'testing' stamp: 'spfa 9/24/2006 10:07'!isList	^ self isList: (IdentitySet with: self)! !!ConsCell methodsFor: 'testing' stamp: 'spfa 9/24/2006 10:07'!isList: anIdentitySet	(anIdentitySet includes: cdr) ifTrue: [^ false].	anIdentitySet add: self.	^ cdr isNil or: [cdr isConsCell and: [cdr isList: anIdentitySet]]! !!ConsCell methodsFor: 'procedure protocol' stamp: 'spfa 6/2/2008 13:17'!isMacro	^ car == #macro! !!ConsCell methodsFor: 'accessing' stamp: 'spfa 6/3/2006 01:25'!last	^ cdr ifNil: [self] ifNotNil: [cdr last]! !!ConsCell methodsFor: 'list operations' stamp: 'spfa 5/20/2008 13:28'!lastCdr: anObject	self lastCell cdr: anObject	! !!ConsCell methodsFor: 'list operations' stamp: 'spfa 5/20/2008 13:28'!lastCell	| cell |	cell _ self.	[cell cdr notNil] whileTrue: [cell _ cell cdr].	^ cell 	! !!ConsCell methodsFor: 'accessing' stamp: 'spfa 6/3/2006 01:33'!length	cdr isNil ifTrue: [^ 1].	cdr isConsCell ifFalse: [self error: 'not a list'].	^ cdr length + 1! !!ConsCell methodsFor: 'conversion' stamp: 'spfa 6/8/2006 22:01'!listCopy	^ self copy setcdr: (cdr isConsCell ifFalse: [cdr] ifTrue: [cdr listCopy])! !!ConsCell methodsFor: 'accessing' stamp: 'spfa 6/3/2006 01:26'!nth: n	n isZero ifTrue: [^ car].	cdr ifNil: [^ nil].	n = 1 ifTrue: [^ cdr car].	^ cdr nth: n - 1! !!ConsCell methodsFor: 'accessing' stamp: 'spfa 6/6/2006 22:02'!nth: n ifAbsent: aBlock	n isZero ifTrue: [^ car].	cdr ifNil: [^ aBlock value].	n = 1 ifTrue: [^ cdr car].	^ cdr nth: n - 1ifAbsent: aBlock! !!ConsCell methodsFor: 'accessing' stamp: 'spfa 6/3/2006 01:26'!nthCell: n	n isZero ifTrue: [^ self].	n = 1 ifTrue: [^ cdr].	^ cdr nthCell: n - 1! !!ConsCell methodsFor: 'accessing' stamp: 'spfa 6/7/2006 10:59'!nthCell: n ifAbsent: aBlock	n isZero ifTrue: [^ self].	n = 1 ifTrue: [^ cdr ifNil: [aBlock value]].	^ cdr nthCell: n - 1 ifAbsent: aBlock! !!ConsCell methodsFor: 'accessing' stamp: 'spfa 6/3/2006 01:26'!nthcdr: n	n isZero ifTrue: [^ self].	n = 1 ifTrue: [^ cdr].	^ cdr nthcdr: n - 1! !!ConsCell methodsFor: 'accessing' stamp: 'spfa 6/6/2006 22:08'!nthcdr: n ifAbsent: aBlock	n isZero ifTrue: [^ self].	cdr ifNil: [n = 1 ifTrue: [^ nil] ifFalse: [aBlock value]].	n = 1 ifTrue: [^ cdr].	^ cdr nthcdr: n - 1ifAbsent: aBlock! !!ConsCell methodsFor: 'printing' stamp: 'spfa 10/10/2006 13:49'!printOn: aStream	self printOn: aStream forLisp: nil! !!Array methodsFor: '*ConsCell' stamp: 'spfa 3/23/2007 17:26'!printOn: aStream depth: aNumber forLisp: aLisp level: cpl maxLevel: mpl length: len maxLength: mlen done: anIdentitySet cycles: anIdentityDictionary	(anIdentityDictionary keys includes: self)	ifTrue: 	[		aStream nextPut: $#; 				nextPutAll: (anIdentityDictionary at: self) asString; 				nextPut: $=.		anIdentitySet add: self.	].	aStream nextPut: $#; nextPut: $(.	self do: [:element | 		(anIdentitySet includes: element)		ifTrue:		[			aStream nextPut: $#; 				nextPutAll: (anIdentityDictionary at: element) asString; 				nextPut: $#		]		ifFalse:		[			element printOn: aStream depth: aNumber forLisp: aLisp 				level: cpl maxLevel: mpl length: len maxLength: mlen 				done: anIdentitySet cycles: anIdentityDictionary		].		aStream space	].	self ifNotEmpty: [aStream skip: -1].	aStream nextPut: $)! !!ConsCell methodsFor: 'printing' stamp: 'spfa 3/24/2007 18:27'!printOn: aStream depth: aNumber forLisp: aLisp level: cpl maxLevel: mpl length: len maxLength: mlen done: anIdentitySet cycles: anIdentityDictionary	"the so-called 'level' controls the depth of nesting cons cells	the 'length' controls the numbers of elements in a list to be printedboth refers to standard Common Lisp variables: respectively *print-level* and *print-length*	see Common Lisp the Language,  2nd edition, chapter 22.1.6"	| depth |	depth _ aNumber.	(anIdentityDictionary keys includes: self)	ifTrue: 	[		aStream nextPut: $#; 				nextPutAll: (anIdentityDictionary at: self) asString; 				nextPut: $=.		anIdentitySet add: self.	].	depth isZero ifTrue: [aStream nextPut: $(].	(car isConsCell | car isArray) ifTrue: 	[		(anIdentitySet includes: car) 		ifTrue: 		[			aStream nextPut: $#; 					nextPutAll: (anIdentityDictionary at: car) asString; 					nextPut: $#		]		ifFalse:		[			(mpl notNil and: [cpl >= mpl]) 				ifTrue: [aStream nextPut: $#]				ifFalse: 				[					car printOn: aStream depth: 0 forLisp: aLisp 						level: cpl + 1 maxLevel: mpl length: mlen maxLength: mlen						done: anIdentitySet cycles: anIdentityDictionary				]		]	]	ifFalse: [car printOn: aStream depth: depth + 1 forLisp: aLisp 						level: cpl + 1 maxLevel: mpl length: mlen maxLength: mlen						done: anIdentitySet cycles: anIdentityDictionary].	cdr ifNil: [^ aStream nextPut: $)].	aStream space.	(len notNil and: [len = 1]) ifTrue: [^ aStream nextPutAll: '...)'].	(cdr isConsCell		and: [(anIdentitySet includes: cdr) not]		and: [(anIdentityDictionary keys includes: cdr) not]) ifTrue: 	[		^ cdr printOn: aStream depth: depth + 1 forLisp: aLisp 			level: cpl maxLevel: mpl 			length: (len ifNotNil: [len - 1]) maxLength: mlen			done: anIdentitySet cycles: anIdentityDictionary	].	aStream nextPut: $.; space. 	(anIdentitySet includes: cdr) 			ifTrue: 	[		aStream nextPut: $#; 			nextPutAll: (anIdentityDictionary at: cdr) asString; 			nextPut: $#	]	ifFalse: 	[		cdr printOn: aStream depth: 0 forLisp: aLisp 			level: cpl maxLevel: mpl			length: (len ifNotNil: [len - 1]) maxLength: mlen		 	done: anIdentitySet cycles: anIdentityDictionary	].	aStream nextPut: $)! !!Array methodsFor: '*ConsCell' stamp: 'spfa 3/24/2007 16:33'!printOn: aStream forLisp: aLisp	| mlen mlev |	mlen _ aLisp ifNil: [nil] ifNotNil: [aLisp printLength].	mlev _ aLisp ifNil: [nil] ifNotNil: [aLisp printLevel].	(aLisp isNil or: [aLisp printCircle == aLisp trueValue])	ifTrue:	[		^ self printOn: aStream depth: 0 forLisp: aLisp 			level: 1 maxLevel: mlev length: mlen maxLength: mlen 			done: IdentitySet new cycles: self cycles	].	self printOn: aStream depth: 0 forLisp: aLisp 		level: 1 maxLevel: mlev length: mlen maxLength: mlen 		done: IdentitySet new cycles: IdentityDictionary new! !!ConsCell methodsFor: 'printing' stamp: 'spfa 3/24/2007 16:32'!printOn: aStream forLisp: aLisp	| mlen mlev |	mlen _ aLisp ifNil: [nil] ifNotNil: [aLisp printLength].	mlev _ aLisp ifNil: [nil] ifNotNil: [aLisp printLevel].	(aLisp isNil or: [aLisp printCircle == aLisp trueValue])	ifTrue:	[		^ self printOn: aStream depth: 0 forLisp: aLisp 			level: 1 maxLevel: mlev length: mlen maxLength: mlen 			done: IdentitySet new cycles: self cycles	].	self printOn: aStream depth: 0 forLisp: aLisp 		level: 1 maxLevel: mlev length: mlen maxLength: mlen 		done: IdentitySet new cycles: IdentityDictionary new! !!ConsCell methodsFor: 'list operations' stamp: 'spfa 3/23/2007 10:01'!safeDo: aBlock	^ self safeDo: aBlock done: IdentitySet new! !!ConsCell methodsFor: 'list operations' stamp: 'spfa 3/23/2007 10:01'!safeDo: aBlock done: anIdentitySet	(anIdentitySet includes: car)		ifFalse: [aBlock value: self car. anIdentitySet add: car].	((anIdentitySet includes: cdr) 		or: [cdr isConsCell not]) ifTrue: [^ self].	cdr safeDo: aBlock done: anIdentitySet! !!ConsCell methodsFor: 'accessing' stamp: 'spfa 10/22/2006 00:11'!safeLength	cdr isNil ifTrue: [^ 1].	cdr isConsCell ifFalse: [^ 2].	^ cdr safeLength + 1! !!ConsCell methodsFor: 'conversion' stamp: 'spfa 4/14/2007 00:30'!safeStoreTopFormsIn: aStream	aStream nextPut: car.	cdr isConsCell ifTrue: [cdr safeStoreTopFormsIn: aStream] ! !!ConsCell methodsFor: 'conversion' stamp: 'spfa 4/14/2007 00:31'!safeTopForms	cdr ifNil: [^ {car}].	cdr isConsCell ifTrue:	[		cdr cdr ifNil: [^ {car . cdr car}].		cdr cdr isConsCell ifTrue:			[cdr cdr cdr ifNil: [^ {car . cdr car . cdr cdr car}]]	].	^ Array streamContents: [:stream | self safeStoreTopFormsIn: stream]! !!UndefinedObject methodsFor: '*ConsCell' stamp: 'spfa 4/14/2007 14:46'!safeTopForms	^ #()! !!ConsCell methodsFor: 'accessing' stamp: 'spfa 6/3/2006 01:26'!second	^ cdr car! !!ConsCell methodsFor: 'accessing' stamp: 'spfa 6/3/2006 01:26'!setcar: anObject	self car: anObject! !!ConsCell methodsFor: 'accessing' stamp: 'spfa 6/3/2006 01:26'!setcdr: anObject	self cdr: anObject! !!Array methodsFor: '*ConsCell' stamp: 'spfa 3/23/2007 17:10'!storeCycles: anIdentityDictionary with: anIdentitySet	(anIdentitySet includes: self)	ifTrue: 	[		(anIdentityDictionary keys includes: self)			ifFalse: [anIdentityDictionary add: self -> (anIdentityDictionary size + 1)].		^ anIdentityDictionary	]. 	anIdentitySet add: self.	self do: [:ea |		(ea isConsCell | ea isArray) ifTrue:			[ea storeCycles: anIdentityDictionary with: anIdentitySet]].	^ anIdentityDictionary! !!ConsCell methodsFor: 'testing' stamp: 'spfa 3/23/2007 16:48'!storeCycles: anIdentityDictionary with: anIdentitySet	(anIdentitySet includes: self)	ifTrue: 	[		(anIdentityDictionary keys includes: self)			ifFalse: [anIdentityDictionary add: self -> (anIdentityDictionary size + 1)].		^ anIdentityDictionary	]. 	anIdentitySet add: self.	(car isConsCell | car isArray) ifTrue: 		[car storeCycles: anIdentityDictionary with: anIdentitySet].	(cdr isConsCell | cdr isArray) ifTrue: 		[cdr storeCycles: anIdentityDictionary with: anIdentitySet].	^ anIdentityDictionary! !!ConsCell methodsFor: 'printing' stamp: 'spfa 6/3/2006 01:29'!storeOn: aStream	aStream nextPutAll: '(ConsCell car: '.	car storeOn: aStream.	aStream nextPutAll: ' cdr: '.	cdr storeOn: aStream.	aStream nextPut: $)! !!ConsCell methodsFor: 'conversion' stamp: 'spfa 4/14/2007 00:33'!storeTopFormsIn: aStream	aStream nextPut: car.	cdr ifNil: [^ self].	cdr storeTopFormsIn: aStream ! !!ConsCell methodsFor: 'conversion' stamp: 'spfa 6/24/2008 18:18'!tailClass	^ self class! !!ConsCell methodsFor: 'accessing' stamp: 'spfa 6/3/2006 01:27'!third	^ cdr cdr car! !!ConsCell methodsFor: 'conversion' stamp: 'spfa 4/13/2007 21:56'!topForms	cdr ifNil: [^ {car}].	cdr cdr ifNil: [^ {car . cdr car}].	cdr cdr cdr ifNil: [^ {car . cdr car . cdr cdr car}].	^ Array streamContents: [:stream | self storeTopFormsIn: stream]! !!UndefinedObject methodsFor: '*ConsCell' stamp: 'spfa 9/23/2006 20:42'!topForms	^ #()! !!ConsCell methodsFor: 'tree operations' stamp: 'spfa 10/18/2006 09:28'!treeDo: aBlock	aBlock value: self.	car isConsCell ifTrue: [car treeDo: aBlock].	cdr isConsCell ifTrue: [cdr treeDo: aBlock]! !!ConsCell methodsFor: 'list operations' stamp: 'spfa 6/23/2008 14:52'!with: aConsCell collect: aBlock	^ self class car: (aBlock value: car value: aConsCell car)		cdr: ((cdr isConsCell and: [aConsCell cdr isConsCell])					ifTrue: [cdr with: aConsCell cdr collect: aBlock] ifFalse: [cdr])! !!ConsCell methodsFor: 'testing' stamp: 'spfa 3/24/2007 16:27'!withCut	| cons c2 |	cons _ self veryDeepCopy.	c2 _ cons cdr.	cons cdr: nil.			^ c2! !